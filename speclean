#!/usr/bin/env python3

######################################################################
#                        Main/testing
######################################################################

def dump_tokens(s):
    print("LEXING <%s>"%s)
    lex.input(s)
    while True:
        t = lex.token()
        if not t:
            break
        print("> %-10.10s <%s>"%(t.type, t.value))
    print()

def dump_parsing(s, env={}):
    #dump_tokens(s)
    print("PARSING %s"%s)
    if env:
        for k,v in env.items():
            print("  assuming %%%s = %s"%(k, to_str_wrapper(v)))
    r = yacc.parse(s)
    print("=> %s"%r.to_str())
    ev = r.evaluate(env)
    res = expr_to_bool_or_none(ev)
    if res is None:
        print("=>", ev.to_str())
    else:
        print("=>", ev, "(decidable!)")
    print()


def cmp_expand(s):
    read = yacc.parse(s)
    if not read:
        print("failed to parse %s"%s)
        return
    ev = read.evaluate(env={'def':42, 'undef':None})
    res = expr_to_bool_or_none(ev)
    rpmres = expand_with_rpmspec('%define def 42\n'+s)

    if res is None:
        print("cant fully expand %s => %s"%(read.to_str(), ev.to_str()))
    else:
        res = str(ev)
        op = '==' if rpmres == res else '!='
        print('%s => rpm<%s> %s <%s>'%(s, rpmres, op, res))

def dump_rpmspec(s):
    print("<%s> expands to <%s>"%(s, expand_with_rpmspec(s)))

def dump_rpmspec_test(s):
    res = expand_with_rpmspec("%if "+s+"\ntrue\n%else\nfalse\n%endif")
    print("<%s> is %s"%(s, res =='true'))

def main():
    cmp_expand("%{?def:1}")
    cmp_expand("%{?def:2}")
    cmp_expand("%{def:2}")
    cmp_expand("%{?!def}")
    cmp_expand("%{?!def:2}")

    cmp_expand("%{?undef:1}")
    cmp_expand("%{?undef:2}")
    cmp_expand("%{undef:2}")
    cmp_expand("%{?!undef}")
    cmp_expand("%{?!undef:2}")

    dump_rpmspec('%define val 0\n0%{?val:1}')
    dump_rpmspec('0%{?version:1}')
    dump_rpmspec('0%{?version}')
    dump_rpmspec('0%{?undef}')
    dump_rpmspec('0%{?undef:1}')
    dump_rpmspec('0%{?!version}')
    dump_rpmspec('0%{?!undef}')
    dump_rpmspec('0%{?!version:1}')
    dump_rpmspec('0%{?!undef:1}')
    dump_rpmspec('0%{undef:1}')
    dump_rpmspec('0%{version:1}')
    #dump_tokens(r'''1 + 2 * 3''')
    #dump_tokens(r'''abc_ "foo \" bar"''')
    #dump_tokens(r'''1!=2 a || b && c''')
    #dump_tokens(r'''0 %foo < 4''')
    #dump_tokens(r'''0%foo < 4''')
    #dump_parsing("1+1+5+8*2+1*4")
    #dump_parsing("%foo+1+1*3+1+1", env={'foo':1})
    #dump_parsing("%foo>0 && %other_var+1+1", env={'foo':1})
    #dump_parsing("%foo>0 && %other_var+1+1", env={'foo':1})
    #dump_parsing("%bar<10 || %foo+2>0", env={'foo':RangedValueExpr(-1, HI_INF)})
    #dump_parsing("%v == 1", env={'v': RangedValueExpr(0,10)})
    dump_parsing('''%s == aaa && 5 <= %v+1 && %v <= 5''', env={'s':'aaa','v': RangedValueExpr(4,10)})
    dump_parsing('''%s == aaa && 5 <= 1*(%v+1) && %v <= 5''', env={'s':'aaa','v': RangedValueExpr(4,10)})
    #dump_parsing("0%suse_version+1 < 1110 && (%other_var+1+1) && %suse_version > 500 || 0", env={'suse_version':600})
    #print("<%s>"%expand_with_rpmspec('(%xyz) (%?xyz) (%?name) (%{?!xyz:%{?!abc:repl}})'))
    dump_rpmspec('%abc')
    dump_rpmspec('%{abc}')
    dump_rpmspec('a%bcdf')
    dump_rpmspec('a%%bcdf')
    dump_rpmspec('a%%%bcdf')
    dump_rpmspec('a%%%%bcdf')
    dump_rpmspec_test(r'''%(echo '"\\abc1"') == "abc1"''')


######################################################################
#                          Lexical analysis
######################################################################

from ply import lex

tokens = (
    'NUM', 'PLUS', 'MINUS', 'MUL', 'DIV', 'IDENT', 'QSTRING',
    'LE', 'LT', 'EQ', 'NEQ', 'GE', 'GT', 'AND', 'OR', 'NOT',
    'LPAR', 'RPAR', 'LBRA', 'RBRA', 'PERCENT', 'QMARK', 'COLON',
)

t_PLUS    = r'\+'
t_MINUS   = r'-'
t_MUL     = r'\*'
t_DIV     = r'/'
t_LE      = r'<='
t_LT      = r'<'
t_EQ      = r'=='
t_NEQ     = r'!='
t_GE      = r'>='
t_GT      = r'>'
t_AND     = r'&&'
t_OR      = r'\|\|'
t_NOT     = r'!'
t_LPAR    = r'\('
t_RPAR    = r'\)'
t_LBRA    = r'\{'
t_RBRA    = r'\}'
t_PERCENT = r'%'
t_NUM     = r'\d+'
t_IDENT   = r'[a-zA-Z_][a-zA-Z0-9_]*'
t_QSTRING = r'"(?:[^"\\]|\\.)*"'
t_QMARK   = r'\?'
t_COLON   = r':'

BINOP_VAL_TO_TOK = {
    r'+' : t_PLUS,
    r'-' : t_MINUS,
    r'*' : t_MUL,
    r'/' : t_DIV,
    r'<=': t_LE,
    r'<' : t_LT,
    r'==': t_EQ,
    r'!=': t_NEQ,
    r'>=': t_GE,
    r'>' : t_GT,
    r'&&': t_AND,
    r'||': t_OR,
}
BINOP_TOK_TO_VAL = {v: k for k, v in BINOP_VAL_TO_TOK.items()}

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

t_ignore = ' \t'

def t_error(t):
    print("illegal char <%s>"%t.value)
    t.lexer.skip(1)

lex.lex()

######################################################################
#                            AST definitions
######################################################################

# spec conditional expressions only have 2 types: ints and strings
# TODO: document semantics of operators vs. type of operands
# TODO: for now assume python semantics
BIN_OPS = {
    t_PLUS:  lambda a, b: a+b,
    t_MINUS: lambda a, b: a-b,
    t_MUL:   lambda a, b: a*b,
    t_DIV:   lambda a, b: a//b,
    t_LT:    lambda a, b: 1 if a<b  else 0,
    t_LE:    lambda a, b: 1 if a<=b else 0,
    t_GE:    lambda a, b: 1 if a>=b else 0,
    t_GT:    lambda a, b: 1 if a>b  else 0,
    t_EQ:    lambda a, b: 1 if a==b else 0,
    t_NEQ:   lambda a, b: 1 if a!=b else 0,
}

def expr_range(e):
    if hasattr(e, "vrange"):
        return e.vrange
    return None

def to_str_wrapper(v, env={}):
    if isinstance(v, int):
        return "%d"%v
    elif isinstance(v, str):
        return v
    else:
        return v.to_str(env)

def bin_op_wrapper(a, op, b):
    ar = expr_range(a)
    br = expr_range(b)

    if (isinstance(a, int) and isinstance(b, int)) or \
       (isinstance(a, str) and isinstance(b, str)):
        return BIN_OPS[op](a,b)
    elif isinstance(a, int) and br:
        if op in (t_PLUS, t_MINUS):
            return BinOpExpr(a, op, b,
                             vrange=RangedValueExpr(BIN_OPS[op](a,br.lo),
                                                    BIN_OPS[op](a,br.hi)))
        elif op == t_MUL:
            if a == 0:
                return 0
            elif a == 1:
                return b
        elif op == t_LT:
            if a < br.lo: return 1
            elif a > br.hi: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_LE: # XXX check if really same
            if a <= br.lo: return 1
            elif a > br.hi: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GT:
            if a > br.hi: return 1
            elif a < br.lo: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GE: # XXX check if really same
            if a >= br.hi: return 1
            elif a < br.lo: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_EQ:
            if not br.contains(a):
                return 0
        elif op == t_NEQ:
            if not br.contains(a):
                return 1
        return None
    elif isinstance(a, RangedValueExpr) and isinstance(b, RangedValueExpr):
        if op == t_PLUS:
            return RangedValueExpr(a.lo+b.lo, a.hi+b.hi)
        print("XXX: not smart about ranged-ranged binary operations yet!")
        return None
    elif ar and isinstance(b, int):
        if op in (t_PLUS, t_MINUS):
            return BinOpExpr(a, op, b,
                             vrange=RangedValueExpr(BIN_OPS[op](ar.lo,b),
                                                    BIN_OPS[op](ar.hi,b)))
        elif op == t_MUL:
            if b == 0:
                return 0
            elif b == 1:
                return a
        elif op == t_DIV:
            if b == 1:
                return a
        elif op == t_LT:
            if ar.hi < b: return 1
            elif ar.lo > b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_LE: # XXX check if really same
            if ar.hi <= b: return 1
            elif ar.lo > b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GT:
            if ar.lo > b: return 1
            elif ar.hi < b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GE: # XXX check if really same
            if ar.lo >= b: return 1
            elif ar.hi < b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_EQ:
            if not ar.contains(b):
                return 0
        elif op == t_NEQ:
            if not ar.contains(b):
                return 1
        return None
    #print("A:%s %s B:%s"%(type(a), BINOP_TOK_TO_VAL[op], type(b)))
    return None


# in a boolean context (logic operators)
# - int expressions uses the classic
#   C semantics: zero is false, non-zero true.
# - string expressions are false when empty, true otherwise

# sugar for easier reading
def expr_is_true(e): return expr_to_bool_or_none(e) == True
def expr_is_false(e): return expr_to_bool_or_none(e) == False
def expr_to_bool_or_none(e):
    erange = expr_range(e)
    if isinstance(e, int):
        return e != 0
    elif isinstance(e, str):
        return len(e) != 0
    elif erange and not erange.contains(0):
            return True
    return None

class Expr:
    def evaluate(self, env): pass
    def to_str(self, env=None): pass

def wrap_type(v):
    if isinstance(v, int):
        return NumExpr(v)
    elif isinstance(v, str):
        return len(e) != 0
    elif isinstance(v, Expr):
        return v
    raise Exception("unkown expr type")

class ValueExpr(Expr):
    pass

from decimal import Decimal
LO_INF = Decimal("-infinity")
HI_INF = Decimal("infinity")

def int_range_to_str(v):
    if v == LO_INF:
        return "-inf"
    elif v == HI_INF:
        return "inf"
    return "%d"%v

class RangedValueExpr(ValueExpr):
    def __init__(self, lo=LO_INF, hi=HI_INF):
            self.lo = min(lo,hi)
            self.hi = max(lo,hi)
    def contains(self, n):
        return self.lo <= n <= self.hi

    def to_str(self, env):
        return "[%s ; %s]"%(int_range_to_str(self.lo),
                            int_range_to_str(self.hi))

class VarExpr(Expr):
    def __init__(self, name, vrange=None, braced=True, test=None, expand=None, zero_prefix=False):
        #print("VarExpr=<%s>"%e)
        self.name = name
        self.vrange = vrange
        self.test = test
        self.expand = expand
        self.braced = braced
        self.zero_prefix = zero_prefix

    def evaluate(self, env):
        if self.name not in env:
            return self

        v = env[self.name]

        if not (v is None or isinstance(v, (RangedValueExpr, int, str))):
            raise Exception("unsupported value type for var"%self.name)

        expand_val = None
        if self.expand:
            expand_val = int(self.expand) if re.match(t_NUM, self.expand) else self.expand

        if self.test:
            if self.test == '?':
                if v is not None:
                    # var known to be defined to something
                    r = expand_val or v
                else:
                    # var is known to be undefined
                    r = 0 if self.zero_prefix else ''
            elif self.test == '?!':
                if v is not None:
                    # var known to be defined to something
                    r = 0 if self.zero_prefix else ''
                else:
                    # var known to be undefined
                    if expand_val:
                        r = expand_val
                    else:
                        r = 0 if self.zero_prefix else ''
        else:
            # no ? or ?! tests
            if v is None:
                r = self.to_str(env)
                print("WARNING: %s will expand to \"%s\", which is very likely not what you want"%(r, r))
            else:
                r = v

        if isinstance(v, RangedValueExpr):
            self.vrange = v
            r = self

        if r == '':
            print("WARNING: var %s will expand to nothing, add zero prefix"%self.name)

        return r

    def to_str(self, env=None):
        r = self.name
        if self.test:
            r = self.test+r
        if self.expand:
            r = r+":"+self.expand
        if self.braced:
            r = "%{"+r+"}"
        if self.zero_prefix:
            r = "0"+r
        return r

class NumExpr(Expr):
    def __init__(self, n):
        #print("NumExpr=<%d>"%n)
        self.n = n

    def evaluate(self, env):
        return self.n

    def to_str(self, env=None):
        return "%d"%self.n

class StrExpr(Expr):
    def __init__(self, s, quoted=True):
        if quoted:
            s = decode_quoted_str(s)
        #print("StrExpr=<%s>"%s)
        self.s = s

    def evaluate(self, env):
        return self.s

    def to_str(self, env=None):
        return '"%s"'%self.s

class NotExpr(Expr):
    def __init__(self, e, vrange=None):
        #print("NotExpr(...)"%e)
        self.e = e
        self.vrange = vrange

    def evaluate(self, env):
        e = self.e.evaluate(env)
        if expr_is_true(e):
            return 0
        elif expr_is_false(e):
            return 1
        else:
            return e

    def to_str(self, env=None):
        return "!("+to_str_wrapper(self.e, env)+")"

class UMinusExpr(Expr):
    def __init__(self, e, vrange=None):
        #print("UMinusExpr(...)")
        self.e = e
        self.vrange = vrange

    def evaluate(self, env):
        e = self.e.evaluate(env)
        if isinstance(e, int):
            return -e
        else:
            r = expr_range(self.e)
            if r:
                r = RangedValueExpr(-r.hi, -r.lo)
            return UMinusExpr(e, vrange=r)

    def to_str(self, env=None):
        return "-("+to_str_wrapper(self.e,env)+")"

class BinOpExpr(Expr):
    def __init__(self, a, op, b, vrange=None):
        #print("BinOpExpr(...,", op," ...")
        self.a = a
        self.b = b
        self.op = op
        self.vrange = vrange

    def evaluate(self, env):
        A = self.a.evaluate(env)
        B = self.b.evaluate(env)

        if self.op in (t_PLUS, t_MINUS, t_MUL, t_DIV, t_GT, t_GE, t_LE, t_LT, t_EQ, t_NEQ):
            r = bin_op_wrapper(A, self.op, B)
            if r is not None:
                return r

        elif self.op == t_AND:
            if expr_is_false(A):
                return 0
            if expr_is_false(B):
                return 0
            if expr_is_true(A) and expr_is_true(B):
                return 1
            if expr_is_true(A):
                return B
            if expr_is_true(B):
                return A

        elif self.op == t_OR:
            if expr_is_true(A):
                return 1
            if expr_is_true(B):
                return 1
            if expr_is_false(A) and expr_is_false(B):
                return 0
            if expr_is_false(A):
                return B
            if expr_is_false(B):
                return A

        return BinOpExpr(A, self.op, B)

    def to_str(self, env=None):
        return "(%s %s %s)"%(to_str_wrapper(self.a,env), BINOP_TOK_TO_VAL[self.op], to_str_wrapper(self.b,env))


######################################################################
#                         Parsing
######################################################################

from ply import yacc

precedence = (
    ('left', 'AND', 'OR'),
    ('left', 'LE', 'LT', 'EQ', 'NEQ', 'GE', 'GT'),
    ('right', 'NOT'),
    ('left', 'PLUS', 'MINUS'),
    ('left', 'MUL', 'DIV'),
     # special precedence rule for unary minus
    ('right', 'UMINUS'),
)

def p_expr_num(p):
    'expr : NUM'
    p[0] = NumExpr(int(p[1]))

def p_expr_qstr(p):
    'expr : QSTRING'
    p[0] = StrExpr(p[1])

def p_expr_bare_str(p):
    'expr : IDENT'
    p[0] = StrExpr(p[1], quoted=False)

def p_expr_group(p):
    'expr : LPAR expr RPAR'
    p[0] = p[2]

def p_var_bare(p):
    'var : PERCENT IDENT'
    p[0] = VarExpr(p[2], braced=False)

def p_var_braced(p):
    'var : PERCENT LBRA IDENT var_expand RBRA'
    # accept var_expand here because rpmspec does, but it doenst make sense...
    p[0] = VarExpr(p[3], expand=p[4])

def p_empty(p):
    'empty :'
    pass

def p_var_expand_val(p):
    '''var_expand : COLON NUM
                  | COLON IDENT
                  | empty'''
    if len(p) == 3:
        p[0] = p[2]
    else:
        p[0] = None


def p_var_qmark(p):
    'var : PERCENT LBRA QMARK IDENT var_expand RBRA'
    p[0] = VarExpr(p[4], test='?', expand=p[5])

def p_var_qmark_not(p):
    'var : PERCENT LBRA QMARK NOT IDENT var_expand RBRA'
    p[0] = VarExpr(p[5], test='?!', expand=p[6])

def p_expr_zvar(p):
    'expr : NUM var'
    if p[1] != '0':
        raise Exception("cannot use <num>%var syntax when num is non-zero")
    v = p[2]
    v.zero_prefix = True
    p[0] = v

def p_expr_var(p):
    'expr : var'
    p[0] = p[1]

def p_expr_uminus(p):
    'expr : MINUS expr %prec UMINUS'
    p[0] = UMinusExpr(p[2])

def p_expr_not(p):
    'expr : NOT expr'
    p[0] = NotExpr(p[2])

def p_expr_binop(p):
    '''expr : expr AND   expr
            | expr OR    expr
            | expr EQ    expr
            | expr NEQ   expr
            | expr LT    expr
            | expr LE    expr
            | expr GT    expr
            | expr GE    expr
            | expr PLUS  expr
            | expr MINUS expr
            | expr MUL   expr
            | expr DIV   expr'''
    p[0] = BinOpExpr(p[1], BINOP_VAL_TO_TOK[p[2]], p[3])

yacc.yacc()

######################################################################
#                      Spec file things
######################################################################
import re
import subprocess
import tempfile

IF_RX = re.compile(r"^\s*%if ")
IFARCH_RX = re.compile(r"^\s*%ifarch ")
IFNARCH_RX = re.compile(r"^\s*%ifnarch ")
ELSE_RX = re.compile(r"^\s*%else")
ENDIF_RX = re.compile(r"^\s*%endif")

def expand_with_rpmspec(s):
    beg = '#----xxxx-BEG-xxxx----\n'
    end = '\n#----xxxx-END-xxxx----\n'
    src = 'Summary: test summary\nName: test\n\nVersion: 1.2\nRelease: 1\n'+ \
          'License: GPL\n%description\n%prep\n'+beg+s+end+'%build\n%install\n'+ \
          '%clean\n%files\n%doc\n%changelog\n'
    with tempfile.NamedTemporaryFile('w+') as tmp:
        tmp.write(src)
        tmp.flush()
        out = subprocess.check_output(['rpmspec', '-P', tmp.name]).decode('utf-8')

    m = re.search(beg+'(.*?)'+end, out, flags=re.M|re.DOTALL)
    return m.group(1)

class IfExpr:
    def __init__(self, cond, arch=None):
        self.cond = cond
        self.arch = arch
        self.is_in_else = False
        self.then_lines = []
        self.else_lines = []
        self.current = self.then_lines

    def set_else(self):
        self.current = self.else_lines

    def append(self, s):
        self.current.append(s)

def print_res(x,n=0):
    if isinstance(x, IfExpr):
        print((".."*n)+x.cond)
        for y in x.then_lines:
            print_res(y, n+1)
        if len(x.else_lines) > 0:
            print((".."*n)+"%else")
            for y in x.else_lines:
                print_res(y, n+1)
        print((".."*n)+"%endif")
    elif isinstance(x, list):
        for y in x:
            print_res(y, n)
    else:
        print((".."*n)+x)

def parse(fn):
    last = []
    stack = [last]

    for l in open(fn).readlines():
        l = l[:-1]
        if IF_RX.match(l):
            last = IfExpr(l)
            stack.append(last)
        elif IFARCH_RX.match(l):
            last = IfExpr(l, arch=True)
            stack.append(last)
        elif IFNARCH_RX.match(l):
            last = IfExpr(l, arch=False)
            stack.append(last)
        elif ELSE_RX.match(l):
            last.set_else()
        elif ENDIF_RX.match(l):
            stack.pop()
            p = stack[-1]
            p.append(last)
            last = p
        else:
            last.append(l)

    print_res(last)


######################################################################
#                          Utils
######################################################################

import re
import codecs

ESCAPE_SEQUENCE_RE = re.compile(r'''
    ( \\U........      # 8-digit hex escapes
    | \\u....          # 4-digit hex escapes
    | \\x..            # 2-digit hex escapes
    | \\[0-7]{1,3}     # Octal escapes
    | \\N\{[^}]+\}     # Unicode characters by name
    | \\[\\'"abfnrtv]  # Single-character escapes
    )''', re.UNICODE | re.VERBOSE)

def decode_quoted_str(s):
    def decode_match(match):
        return codecs.decode(match.group(0), 'unicode-escape')

    return ESCAPE_SEQUENCE_RE.sub(decode_match, s[1:-1])

if __name__ == '__main__':
    main()
