#!/usr/bin/env python3

######################################################################
#                        Main/testing
######################################################################

def dump_tokens(s):
    print("LEXING <%s>"%s)
    lex.input(s)
    while True:
        t = lex.token()
        if not t:
            break
        print("> %-10.10s <%s>"%(t.type, t.value))
    print()

def dump_parsing(s, env={}):
    #dump_tokens(s)
    print("PARSING %s"%s)
    if env:
        for k,v in env.items():
            print("  assuming %%%s = %s"%(k, to_str_wrapper(v)))
    r = yacc.parse(s)
    print("=> %s"%r.to_str())
    ev = r.evaluate(env)
    res = expr_to_bool_or_none(ev)
    if res is None:
        print("=>", ev.to_str())
    else:
        print("=>", ev, "(decidable!)")
    print()


def main():
    #dump_tokens(r'''1 + 2 * 3''')
    #dump_tokens(r'''abc_ "foo \" bar"''')
    #dump_tokens(r'''1!=2 a || b && c''')
    #dump_tokens(r'''0 %foo < 4''')
    #dump_tokens(r'''0%foo < 4''')
    dump_parsing("1+1+5+8*2+1*4")
    #dump_parsing("%foo+1+1*3+1+1", env={'foo':1})
    #dump_parsing("%foo>0 && %other_var+1+1", env={'foo':1})
    #dump_parsing("%foo>0 && %other_var+1+1", env={'foo':1})
    dump_parsing("%foo-1>0", env={'foo':RangedValueExpr(LO_INF, -10)})
    #dump_parsing("0%suse_version+1 < 1110 && (%other_var+1+1) && %suse_version > 500 || 0", env={'suse_version':600})


######################################################################
#                          Lexical analysis
######################################################################

from ply import lex

tokens = (
    'NUM', 'PLUS', 'MINUS', 'MUL', 'DIV', 'IDENT', 'QSTRING',
    'LE', 'LT', 'EQ', 'NEQ', 'GE', 'GT', 'AND', 'OR', 'NOT',
    'LPAR', 'RPAR', 'LBRA', 'RBRA', 'PERCENT',
)

t_PLUS    = r'\+'
t_MINUS   = r'-'
t_MUL     = r'\*'
t_DIV     = r'/'
t_LE      = r'<='
t_LT      = r'<'
t_EQ      = r'=='
t_NEQ     = r'!='
t_GE      = r'>='
t_GT      = r'>'
t_AND     = r'&&'
t_OR      = r'\|\|'
t_NOT     = r'!'
t_LPAR    = r'\('
t_RPAR    = r'\)'
t_LBRA    = r'\{'
t_RBRA    = r'\}'
t_PERCENT = r'%'
t_NUM     = r'\d+'
t_IDENT   = r'[a-zA-Z_][a-zA-Z0-9_]*'
t_QSTRING = r'"(?:[^"\\]|\\.)*"'

BINOP_VAL_TO_TOK = {
    r'+' : t_PLUS,
    r'-' : t_MINUS,
    r'*' : t_MUL,
    r'/' : t_DIV,
    r'<=': t_LE,
    r'<' : t_LT,
    r'==': t_EQ,
    r'!=': t_NEQ,
    r'>=': t_GE,
    r'>' : t_GT,
    r'&&': t_AND,
    r'||': t_OR,
}
BINOP_TOK_TO_VAL = {v: k for k, v in BINOP_VAL_TO_TOK.items()}

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

t_ignore = ' \t'

def t_error(t):
    print("illegal char <%s>"%t.value)
    t.lexer.skip(1)

lex.lex()

######################################################################
#                            AST definitions
######################################################################

# spec conditional expressions only have 2 types: ints and strings
# TODO: document semantics of operators vs. type of operands
# TODO: for now assume python semantics
BIN_OPS = {
    t_PLUS:  lambda a, b: a+b,
    t_MINUS: lambda a, b: a-b,
    t_MUL:   lambda a, b: a*b,
    t_DIV:   lambda a, b: a//b,
    t_LT:    lambda a, b: 1 if a<b  else 0,
    t_LE:    lambda a, b: 1 if a<=b else 0,
    t_GE:    lambda a, b: 1 if a>=b else 0,
    t_GT:    lambda a, b: 1 if a>b  else 0,
    t_EQ:    lambda a, b: 1 if a==b else 0,
    t_NEQ:   lambda a, b: 1 if a!=b else 0,
}

def to_str_wrapper(v, env={}):
    if isinstance(v, int):
        return "%d"%v
    elif isinstance(v, str):
        return v
    else:
        return v.to_str(env)

def bin_op_wrapper(a, op, b):
    if isinstance(a, int) and isinstance(b, int):
        return BIN_OPS[op](a,b)
    elif isinstance(a, int) and isinstance(b, RangedValueExpr):
        if op in (t_PLUS, t_MINUS):
            return RangedValueExpr(BIN_OPS[op](a,b.lo), BIN_OPS[op](a,b.hi))
        elif op == t_LT:
            if a < b.lo: return 1
            elif a > b.hi: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_LE: # XXX check if really same
            if a < b.lo: return 1
            elif a > b.hi: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GT:
            if a > b.hi: return 1
            elif a < b.lo: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GE: # XXX check if really same
            if a > b.hi: return 1
            elif a < b.lo: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_EQ:
            if not b.contains(a):
                return 0
        elif op == t_NEQ:
            if not b.contains(a):
                return 1
        return None
    elif isinstance(a, RangedValueExpr) and isinstance(b, RangedValueExpr):
        if op == t_PLUS:
            return RangedValueExpr(a.lo+b.lo, a.hi+b.hi)
        print("XXX: not smart about ranged-ranged binary operations yet!")
        return None
    elif isinstance(a, RangedValueExpr) and isinstance(b, int):
        if op in (t_PLUS, t_MINUS):
            return RangedValueExpr(BIN_OPS[op](a.lo,b), BIN_OPS[op](a.hi,b))
        elif op == t_LT:
            if a.hi < b: return 1
            elif a.lo > b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_LE: # XXX check if really same
            if a.hi < b: return 1
            elif a.lo > b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GT:
            if a.lo > b: return 1
            elif a.hi < b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_GE: # XXX check if really same
            if a.lo > b: return 1
            elif a.hi < b: return 0
            #else: return BinOpExpr(a, op, b)
        elif op == t_EQ:
            if not a.contains(b):
                return 0
        elif op == t_NEQ:
            if not a.contains(b):
                return 1
        return None
    print("A:%s %s B:%s"%(type(a), BINOP_TOK_TO_VAL[op], type(b)))
    return None


# in a boolean context (logic operators)
# - int expressions uses the classic
#   C semantics: zero is false, non-zero true.
# - string expressions are false when empty, true otherwise

# sugar for easier reading
def expr_is_true(e): return expr_to_bool_or_none(e) == True
def expr_is_false(e): return expr_to_bool_or_none(e) == False
def expr_to_bool_or_none(e):
    if isinstance(e, int):
        return e != 0
    elif isinstance(e, str):
        return len(e) != 0
    elif isinstance(e, RangedValueExpr):
        if not e.contains(0):
            return True
    return None

class Expr:
    def evaluate(self, env): pass
    def to_str(self, env=None): pass

def wrap_type(v):
    if isinstance(v, int):
        return NumExpr(v)
    elif isinstance(v, str):
        return len(e) != 0
    elif isinstance(v, Expr):
        return v
    raise Exception("unkown expr type")

class ValueExpr(Expr):
    pass

from decimal import Decimal
LO_INF = Decimal("-infinity")
HI_INF = Decimal("infinity")

def int_range_to_str(v):
    if v == LO_INF:
        return "-inf"
    elif v == HI_INF:
        return "inf"
    return "%d"%v

class RangedValueExpr(ValueExpr):
    def __init__(self, lo=LO_INF, hi=HI_INF):
            self.lo = min(lo,hi)
            self.hi = max(lo,hi)
    def contains(self, n):
        return self.lo <= n <= self.hi

    def to_str(self, env):
        return "[%s ; %s]"%(int_range_to_str(self.lo),
                          int_range_to_str(self.hi))

class VarExpr(Expr):
    def __init__(self, name):
        #print("VarExpr=<%s>"%e)
        self.name = name

    def evaluate(self, env):
        if self.name in env:
            return env[self.name]
        return self

    def to_str(self, env=None):
        return "%"+self.name

class NumExpr(Expr):
    def __init__(self, n):
        #print("NumExpr=<%d>"%n)
        self.n = n

    def evaluate(self, env):
        return self.n

    def to_str(self, env=None):
        return "%d"%self.n

class StrExpr(Expr):
    def __init__(self, s):
        #print("StrExpr=<%s>"%s)
        self.s = s

    def evaluate(self, env):
        return self.s

    def to_str(self, env=None):
        return '"%s"'%self.s

class NotExpr(Expr):
    def __init__(self, e):
        #print("NotExpr(...)"%e)
        self.e = e

    def evaluate(self, env):
        e = self.e.evaluate(env)
        if expr_is_true(e):
            return 0
        elif expr_is_false(e):
            return 1
        else:
            return e

    def to_str(self, env=None):
        return "!("+to_str_wrapper(self.e, env)+")"

class UMinusExpr(Expr):
    def __init__(self, e):
        #print("UMinusExpr(...)")
        self.e = e

    def evaluate(self, env):
        e = self.e.evaluate(env)
        if isinstance(e, int):
            return -e
        else:
            return UMinusExpr(e)

    def to_str(self, env=None):
        return "-("+to_str_wrapper(self.e,env)+")"

class BinOpExpr(Expr):
    def __init__(self, a, op, b):
        #print("BinOpExpr(...,", op," ...")
        self.a = a
        self.b = b
        self.op = op

    def evaluate(self, env):
        A = self.a.evaluate(env)
        B = self.b.evaluate(env)

        if self.op in (t_PLUS, t_MINUS, t_MUL, t_DIV, t_GT, t_GE, t_LE, t_LT, t_EQ, t_NEQ):
            r = bin_op_wrapper(A, self.op, B)
            if r is not None:
                return r

        elif self.op == t_AND:
            if expr_is_false(A):
                return 0
            if expr_is_false(B):
                return 0
            if expr_is_true(A) and expr_is_true(B):
                return 1
            if expr_is_true(A):
                return B
            if expr_is_true(B):
                return A

        elif self.op == t_OR:
            if expr_is_true(A):
                return 1
            if expr_is_true(B):
                return 1
            if expr_is_false(A) and expr_is_false(B):
                return 0
            if expr_is_false(A):
                return B
            if expr_is_false(B):
                return A

        return BinOpExpr(A, self.op, B)

    def to_str(self, env=None):
        return "(%s %s %s)"%(to_str_wrapper(self.a,env), BINOP_TOK_TO_VAL[self.op], to_str_wrapper(self.b,env))


######################################################################
#                         Parsing
######################################################################

from ply import yacc

precedence = (
    ('left', 'AND', 'OR'),
    ('left', 'LE', 'LT', 'EQ', 'NEQ', 'GE', 'GT'),
    ('right', 'NOT'),
    ('left', 'PLUS', 'MINUS'),
    ('left', 'MUL', 'DIV'),
     # special precedence rule for unary minus
    ('right', 'UMINUS'),
)

def p_expr_num(p):
    'expr : NUM'
    p[0] = NumExpr(int(p[1]))

def p_expr_qstr(p):
    'expr : QSTRING'
    p[0] = StrExpr(p[1])

def p_expr_bare_str(p):
    'expr : IDENT'
    p[0] = StrExpr(p[1])

def p_expr_group(p):
    'expr : LPAR expr RPAR'
    p[0] = p[2]

def p_expr_var(p):
    'expr : PERCENT IDENT'
    p[0] = VarExpr(p[2])

def p_expr_var_braced(p):
    'expr : PERCENT LBRA IDENT RBRA'
    p[0] = VarExpr(p[3])

def p_expr_zvar(p):
    'expr : NUM PERCENT IDENT'
    if p[1] != '0':
        raise Exception("cannot use <num>%var syntax when num is non-zero")
    p[0] = VarExpr(p[3])

def p_expr_uminus(p):
    'expr : MINUS expr %prec UMINUS'
    p[0] = UMinusExpr(p[2])

def p_expr_not(p):
    'expr : NOT expr'
    p[0] = NotExpr(p[2])

def p_expr_binop(p):
    '''expr : expr AND   expr
            | expr OR    expr
            | expr EQ    expr
            | expr NEQ   expr
            | expr LT    expr
            | expr LE    expr
            | expr GT    expr
            | expr GE    expr
            | expr PLUS  expr
            | expr MINUS expr
            | expr MUL   expr
            | expr DIV   expr'''
    p[0] = BinOpExpr(p[1], BINOP_VAL_TO_TOK[p[2]], p[3])

yacc.yacc()

##############################################################

if __name__ == '__main__':
    main()
